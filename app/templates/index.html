<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mini Exchange</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { margin: 24px; background: #0b0e11; color: #e6e6e6; }
    h1 { margin: 0 0 10px 0; }
    .topbar { display:flex; gap:16px; align-items:baseline; justify-content:space-between; }
    .muted { color: #8c95a3; font-size: 13px; margin-bottom: 16px; }
    .grid { display: grid; gap: 14px; grid-template-columns: 1fr 1fr; }
    .gridCards { display: grid; gap: 14px; grid-template-columns: repeat(auto-fit, minmax(420px, 1fr)); }

    .card { background: #11161d; border: 1px solid #232933; border-radius: 12px; overflow: hidden; }
    .card-head { padding: 12px 14px; display: flex; justify-content: space-between; align-items: baseline; }
    .sym { font-weight: 700; font-size: 18px; letter-spacing: 0.3px; }
    .ref { font-variant-numeric: tabular-nums; color: #cbd5e1; }
    table { width: 100%; border-collapse: collapse; }
    thead th { background: #0d131a; color: #9aa6b2; font-weight: 600; padding: 8px 10px; font-size: 13px; }
    tbody td { padding: 6px 10px; border-top: 1px solid #1c2330; height: 28px; }
    th.right, td.right { text-align: right; }
    th.center, td.center { text-align: center; }
    th.left, td.left { text-align: left; }
    .price { font-variant-numeric: tabular-nums; letter-spacing: 0.2px; }
    .qty { position: relative; display: inline-block; min-width: 64px; padding: 2px 8px; border-radius: 8px; font-variant-numeric: tabular-nums; }
    .qty.bid::before { content: ""; position: absolute; inset: 0; right: 0; width: calc(var(--pct, 0) * 1%); background: #6fe6a8; opacity: 0.25; border-radius: 8px; }
    .qty.ask::before { content: ""; position: absolute; inset: 0; left: 0; width: calc(var(--pct, 0) * 1%); background: #ff8a8a; opacity: 0.25; border-radius: 8px; }
    .qty.empty { opacity: 0.35; }

    .pbox { background:#11161d; border:1px solid #232933; border-radius:12px; padding:14px; }
    .btn { color:#0cf; text-decoration:none; }
    .logout { background:#232933; color:#e6e6e6; border:0; padding:6px 10px; border-radius:8px; cursor:pointer; }
    .ok { color:#6fe6a8; } .bad { color:#ff8a8a; }
  </style>
</head>
<body>
  <div class="topbar">
    <h1>Mini Exchange</h1>
    <!-- Show login/signup by default (JS will swap to "Signed in as ..." if authenticated) -->
    <div id="authbox"><a class="btn" href="/login">Login</a> · <a class="btn" href="/signup">Sign up</a></div>
  </div>

  <div class="muted">
    Top-10 ladder per symbol + your live PnL/position when logged in. — <a class="btn" href="/docs">API docs</a>
  </div>

  <div class="grid">
    <div class="pbox">
      <h3>Your Positions</h3>
      <div id="mebox">
        <div class="muted">Sign in to see your PnL and place orders.</div>
      </div>
    </div>
    <div></div>
  </div>

  <!-- Server-render the skeleton of all cards so content exists even if JS fails -->
  <div id="gridCards" class="gridCards">
    {% for s in symbols %}
      <div class="card" id="card-{{s}}">
        <div class="card-head">
          <div class="sym">{{s}}</div>
          <div class="ref" id="ref-{{s}}">ref: —</div>
        </div>
        <table aria-label="orderbook {{s}}">
          <thead>
            <tr>
              <th class="right"># Bid</th>
              <th class="center">Price</th>
              <th class="left"># Ask</th>
            </tr>
          </thead>
          <tbody id="tb-{{s}}">
            {% for i in range(depth) %}
              <tr>
                <td class="right"><span class="qty empty"></span></td>
                <td class="center price">—</td>
                <td class="left"><span class="qty empty"></span></td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>
    {% endfor %}
  </div>

  <!-- Data hook for JS -->
  <div id="root" data-symbols='{{ symbols_json | safe }}' data-depth='{{ depth }}' style="display:none"></div>

  <!-- Inline JS so we don't depend on /static -->
  <script>
  (function () {
    const root = document.getElementById("root");
    const symbols = JSON.parse(root.dataset.symbols || "[]");
    const DEPTH = Number(root.dataset.depth || "10");
    const wsProto = location.protocol === "https:" ? "wss" : "ws";

    function fmtNum(n, dp = 2) {
      if (n === null || n === undefined) return "—";
      const x = Number(n);
      if (!isFinite(x)) return "—";
      return x.toLocaleString(undefined, { minimumFractionDigits: dp, maximumFractionDigits: 6 });
    }
    const fmtQty = (q) => fmtNum(q, 0);
    const fmtPx  = (p) => fmtNum(p, 2);

    function buildLadder(bids, asks) {
      const bidMap = new Map((bids || []).map(l => [Number(l.px), Number(l.qty)]));
      const askMap = new Map((asks || []).map(l => [Number(l.px), Number(l.qty)]));
      const bidPrices = (bids || []).slice(0, DEPTH).map(l => Number(l.px));
      const askPrices = (asks || []).slice(0, DEPTH).map(l => Number(l.px));
      const prices = Array.from(new Set([...bidPrices, ...askPrices])).sort((a, b) => b - a);
      let maxQty = 1;
      for (const p of prices) maxQty = Math.max(maxQty, bidMap.get(p) || 0, askMap.get(p) || 0);
      return prices.map(p => {
        const bq = bidMap.get(p), aq = askMap.get(p);
        const bpct = Math.min(100, Math.round((bq || 0) / maxQty * 100));
        const apct = Math.min(100, Math.round((aq || 0) / maxQty * 100));
        return `
          <tr>
            <td class="right">
              ${bq ? `<span class="qty bid" style="--pct:${bpct}">${fmtQty(bq)}</span>` : `<span class="qty empty"></span>`}
            </td>
            <td class="center price">${fmtPx(p)}</td>
            <td class="left">
              ${aq ? `<span class="qty ask" style="--pct:${apct}">${fmtQty(aq)}</span>` : `<span class="qty empty"></span>`}
            </td>
          </tr>`;
      }).join("");
    }

    function updateSnapshot(sym, book, ref) {
      const tbody = document.getElementById(`tb-${sym}`);
      if (tbody) tbody.innerHTML = buildLadder(book.bids, book.asks);
      if (ref !== undefined) {
        const r = document.getElementById(`ref-${sym}`);
        if (r) r.textContent = "ref: " + fmtNum(ref);
      }
    }

    async function pollRef(sym) {
      try {
        const r = await fetch(`/reference/${sym}`);
        const j = await r.json();
        const el = document.getElementById(`ref-${sym}`);
        if (el) el.textContent = "ref: " + fmtNum(j.price);
      } catch {}
    }

    function connectWS(sym) {
      const ws = new WebSocket(`${wsProto}://${location.host}/ws/book/${sym}`);
      ws.onmessage = (ev) => {
        try {
          const msg = JSON.parse(ev.data);
          if (msg.type === "snapshot") {
            updateSnapshot(sym, msg.book, msg.ref_price);
            refreshMe();
          }
        } catch {}
      };
      ws.onclose = () => setTimeout(() => connectWS(sym), 1500);
    }

    // Auth / Your metrics
    const authbox = document.getElementById("authbox");
    const mebox = document.getElementById("mebox");

    function renderSignedOut() {
      if (authbox) authbox.innerHTML = `<a class="btn" href="/login">Login</a> · <a class="btn" href="/signup">Sign up</a>`;
      if (mebox) mebox.innerHTML = `<div class="muted">Sign in to see your PnL and place orders.</div>`;
    }

    function renderMe(data) {
      const user = data.user;
      const metrics = data.metrics || {};
      const rows = Object.keys(metrics).sort().map(sym => {
        const m = metrics[sym];
        const total = Number(m.total_pnl || 0);
        return `
          <tr>
            <td>${sym}</td>
            <td class="right">${fmtNum(m.ref)}</td>
            <td class="right">${fmtNum(m.avg_price)}</td>
            <td class="right">${fmtNum(m.position, 0)}</td>
            <td class="right">${fmtNum(m.delta, 0)}</td>
            <td class="right">${fmtNum(m.realized)}</td>
            <td class="right ${total >= 0 ? "ok":"bad"}">${fmtNum(m.total_pnl)}</td>
          </tr>`;
      }).join("");
      if (authbox) {
        authbox.innerHTML = `
          <form method="post" action="/logout" style="display:flex; gap:8px; align-items:center;">
            <div>Signed in as <strong>${user}</strong></div>
            <button class="logout" type="submit">Logout</button>
          </form>`;
      }
      if (mebox) {
        mebox.innerHTML = `
          <table>
            <thead>
              <tr>
                <th class="left">Symbol</th>
                <th class="right">Ref</th>
                <th class="right">Avg</th>
                <th class="right">Pos</th>
                <th class="right">Δ</th>
                <th class="right">Realized</th>
                <th class="right">Total PnL</th>
              </tr>
            </thead>
            <tbody>${rows || `<tr><td colspan="7" class="muted">No trades yet.</td></tr>`}</tbody>
          </table>`;
      }
    }

    async function refreshMe() {
      try {
        const r = await fetch("/me/metrics");
        if (r.status === 401) return renderSignedOut();
        const j = await r.json();
        renderMe(j);
      } catch {
        renderSignedOut();
      }
    }

    // Bootstrap: connect WS + poll refs + render auth
    function bootstrap() {
      symbols.forEach((sym) => {
        connectWS(sym);
        pollRef(sym);
        setInterval(() => pollRef(sym), 60000);
      });
      refreshMe();
      setInterval(refreshMe, 2000);
    }

    bootstrap();
  })();
  </script>
</body>
</html>
